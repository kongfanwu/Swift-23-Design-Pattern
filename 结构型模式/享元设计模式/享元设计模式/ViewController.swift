//
//  ViewController.swift
//  享元设计模式
//
//  Created by wangyang on 2024/8/13.
/*
 享元设计模式（Flyweight Pattern）是一种用于优化性能的软件设计模式，它属于结构型设计模式。享元模式的主要目的是通过共享物件来减少内存使用量，同时分享信息给尽可能多的相似物件，从而降低内存消耗和提高系统性能。
 定义与原理
 享元模式通过区分对象的内部状态和外部状态来实现对象的共享。内部状态是对象可以共享的部分，它在对象的生命周期内不会改变，且可以被多个对象共享。外部状态则是随环境改变而改变的，不能共享，通常由客户端持有。
 结构
 享元模式主要包含以下几个角色：
 抽象享元角色（Flyweight Interface）：为具体享元角色规定了必须实现的方法，外蕴状态就是以参数的形式通过此方法传入。在Java中，这个角色可以由抽象类或接口来担当。
 具体享元角色（Concrete Flyweight）：实现抽象享元角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供存储空间。
 享元工厂角色（Flyweight Factory）：负责创建和管理享元角色。它维护了一个存储享元对象的容器，用于存储已经创建的享元对象，并提供获取享元对象的方法。
 客户端角色（Client）：维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。
 使用场景
 享元模式特别适用于以下场景：
 系统中存在大量细粒度的对象：这些对象只因为外部状态的不同而有所区别，但内部状态可以共享。
 对象的创建成本较高：通过共享可以减少对象的创建数量，从而降低创建成本。
 系统需要节省内存：通过共享可以减少内存中的对象数量，提高内存利用率。
 优点与缺点
 优点
 减少内存中的对象数量：通过共享相似对象，可以显著减少内存中的对象数量。
 提高系统性能：由于减少了对象的创建和销毁，系统的性能可以得到提升。
 外部状态相对独立：外部状态由客户端管理，不会影响到内部状态的共享。
 缺点
 增加编程复杂性：实现享元模式需要将对象的状态分为内部状态和外部状态，增加了编程的复杂性。
 降低代码可读性：由于涉及到对象状态的划分和共享，代码的逻辑可能会变得复杂，降低代码的可读性。
 可能引入线程安全问题：如果多个线程同时访问和修改共享对象，可能会导致线程安全问题。
 示例
 一个典型的享元模式示例是文书处理器中以图形结构来表示字符。每个字符可以参照到一个共享的字形物件，这个物件会被其他有共同特质的字符所分享。只有每个字符在文件中或页面中的位置才需要另外储存。这样，通过共享字形物件，可以显著减少内存的使用量。
 结论
 享元设计模式是一种有效的优化手段，特别适用于需要处理大量相似对象的场景。通过共享对象的内部状态，可以减少内存的使用量，提高系统的性能。然而，实现享元模式也需要注意其可能带来的编程复杂性和线程安全问题。
 */

import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }

    func test() {
        let factory = ColorFactory()
          
        // 获取颜色并显示
        let red = factory.getColor(colorCode: "Red")
        red.display(position: "Top Left")
          
        // 由于使用了享元模式，再次获取"Red"颜色时会返回相同的对象
        let redAgain = factory.getColor(colorCode: "Red")
        redAgain.display(position: "Bottom Right")
          
        // 获取另一个颜色
        let blue = factory.getColor(colorCode: "Blue")
        blue.display(position: "Center")
        
//        在这个例子中，每次调用getColor时，如果请求的颜色代码已经存在于flyweights字典中，那么就会返回该颜色的现有实例，而不是创建一个新的实例。这样，我们就可以通过重用颜色对象来减少内存使用，从而提高性能。
//        请注意，虽然在这个简单的示例中我们没有明确地处理外部状态，但在更复杂的情况下，外部状态可能需要由客户端管理，并在调用享元对象的方法时作为参数传递。
    }
    
    func test2() {
//        客户端使用
//        最后，客户端通过享元工厂来获取棋子对象，并管理棋子的位置（外部状态）。
        let factory = ChessPieceFactory()
          
        // 获取白色棋子并移动到A1位置
        let whitePiece = factory.getChessPiece(color: "White")
        whitePiece.moveTo("A1")
          
        // 由于使用了享元模式，再次获取白色棋子时会返回相同的对象
        // 但我们仍然可以将其移动到另一个位置（外部状态改变）
        let whitePieceAgain = factory.getChessPiece(color: "White")
        whitePieceAgain.moveTo("B2") // 注意：这里实际上移动的是同一个对象
          
        // 获取黑色棋子并移动到C3位置
        let blackPiece = factory.getChessPiece(color: "Black")
        blackPiece.moveTo("C3")
          
        // 强调：虽然白色棋子被移动了两次，但实际上是同一个对象在不同位置被“显示”
        // 这说明外部状态（位置）是由客户端管理的，而内部状态（颜色）是被共享的
        
//        在这个例子中，棋子的颜色作为内部状态被存储在享元对象中，并通过享元工厂进行共享。而棋子的位置作为外部状态，由客户端在调用moveTo方法时提供。这样，我们就可以通过重用颜色相同的棋子对象来减少内存使用，同时保持每个棋子位置的独立性。
//        请注意，虽然在这个例子中moveTo方法看起来像是在修改享元对象的状态，但实际上它并没有改变享元对象的内部状态（颜色）。相反，它演示了如何使用外部状态（位置）与享元对象进行交互。在更复杂的应用中，可能需要更精细地控制内部状态和外部状态的边界。
    }
}

