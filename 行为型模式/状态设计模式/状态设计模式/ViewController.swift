//
//  ViewController.swift
//  状态设计模式
//
//  Created by wangyang on 2024/8/12.
/*
 状态设计模式（State Pattern），又称作状态机模式（State Machine Pattern），是一种重要的行为型设计模式。其核心思想是将一个对象在不同状态下的行为封装在不同的状态类中，每个状态类负责定义对象在该状态下的行为，并在对象的状态发生变化时，将对象的行为切换到新的状态类。这样，对象的行为就随着状态的变化而变化，而对象本身不需要知道如何切换状态或如何执行特定状态下的行为，这些都被封装在状态类中。
 状态设计模式的主要特点包括：
 状态与行为绑定：不同的状态对应不同的行为，状态模式的核心是状态与行为绑定。
 简化条件逻辑：通过将状态相关的行为封装在独立的状态类中，有效地简化了条件逻辑，提高了代码的可维护性和可扩展性。
 提高代码清晰度：将复杂的判断逻辑转移到表示不同状态的一系列类中，使得代码更加清晰、易于理解。
 符合开闭原则：增加新的状态类可以很容易地扩展系统的功能，而不需要修改环境类和其他状态类的代码。
 状态设计模式的结构主要包括以下几个部分：
 环境类（Context）：也称作上下文类，它定义了客户端所感兴趣的接口，并且维护一个指向当前状态对象的引用，这个引用可以动态地改变以改变环境类的行为。
 抽象状态类（State）：这是一个抽象类或接口，它定义了一个或多个环境对象可能呈现的状态，以及在这些状态下对象可能执行的行为。
 具体状态类（ConcreteState）：这是抽象状态类的子类，每一子类都实现了环境的一个特定状态对应的行为。
 状态设计模式的使用场景包括：
 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时。
 一个操作中含有庞大的分支语句，并且这些分支依赖于该对象的状态。
 当一个类必须支持多种在其生命周期中可能改变的行为，并且这些状态改变必须能够被外部事件触发时。
 状态设计模式的优缺点：
 优点：
 封装性好：将状态逻辑封装在状态类中，避免了大量的条件语句，使得代码更加清晰、易于维护。
 扩展性好：增加新的状态类可以很容易地扩展系统的功能，而不需要修改环境类和其他状态类的代码。
 状态转换逻辑与状态行为分离：环境类不再负责状态转换的逻辑，这使得状态转换和状态行为的管理更加清晰和独立。
 灵活性高：可以通过组合不同的状态类来创建不同的行为组合，实现更复杂的业务逻辑。
 缺点：
 增加系统复杂性：使用状态模式会增加系统中的类和对象的数量，使得系统变得复杂。
 可能产生过多的状态类：如果系统中状态过多，会导致产生大量的状态类，这可能会增加系统的维护成本。
 状态转换逻辑可能复杂化：虽然状态模式将状态转换逻辑与状态行为分离，但如果状态转换逻辑本身就很复杂，那么这种分离可能会使得系统的整体逻辑变得更加难以理解和维护。
 综上所述，状态设计模式是一种非常有用的设计模式，在处理对象状态变化复杂、状态数量较多的情况下尤其有效。
 */

import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        test2()
    }
    func test2() {
        // 使用示例
        let coffeeMachine = CoffeeMachine()
        coffeeMachine.startBrewing() // 咖啡机空闲，开始加热...
        coffeeMachine.startBrewing() // 咖啡机正在加热...（注意：这里实际上应该只显示一次加热，因为加热是自动的，但为了演示状态变化，我们再次调用）
        coffeeMachine.startBrewing() // 咖啡机正在冲泡咖啡...（假设加热已完成）
        coffeeMachine.startBrewing() // 咖啡机空闲，开始加热...（回到空闲状态，准备下一次冲泡）
          
        // 注意：在实际应用中，你可能需要一种机制来防止在加热或冲泡过程中重复触发brew操作，
        // 或者使用定时器来模拟加热和冲泡过程所需的时间。

    }
    func test() {
        // 使用示例
        let order = Order(id: 1)
        order.pay()        // 订单支付成功，状态更新为已支付...
        order.ship()       // 订单已支付，开始发货...
        order.finish()     // 订单已完成。
    }
}

